// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: akash/oracle/v1/prices.proto

package v1

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DataID uniquely identifies a price pair by asset and base denomination
type DataID struct {
	// denom is the asset denomination (e.g., "uakt")
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom" yaml:"denom"`
	// base_denom is the base denomination for the price pair (e.g., "usd")
	BaseDenom string `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom" yaml:"base_denom"`
}

func (m *DataID) Reset()         { *m = DataID{} }
func (m *DataID) String() string { return proto.CompactTextString(m) }
func (*DataID) ProtoMessage()    {}
func (*DataID) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{0}
}
func (m *DataID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataID.Merge(m, src)
}
func (m *DataID) XXX_Size() int {
	return m.Size()
}
func (m *DataID) XXX_DiscardUnknown() {
	xxx_messageInfo_DataID.DiscardUnknown(m)
}

var xxx_messageInfo_DataID proto.InternalMessageInfo

func (m *DataID) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *DataID) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

// PriceDataID identifies price data from a specific source for a specific pair
type PriceDataID struct {
	// source is the index of the price source (oracle provider)
	Source uint32 `protobuf:"varint,1,opt,name=source,proto3" json:"source" yaml:"source"`
	// denom is the asset denomination
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom" yaml:"denom"`
	// base_denom is the base denomination for the price pair
	BaseDenom string `protobuf:"bytes,3,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom" yaml:"base_denom"`
}

func (m *PriceDataID) Reset()         { *m = PriceDataID{} }
func (m *PriceDataID) String() string { return proto.CompactTextString(m) }
func (*PriceDataID) ProtoMessage()    {}
func (*PriceDataID) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{1}
}
func (m *PriceDataID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceDataID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceDataID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceDataID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceDataID.Merge(m, src)
}
func (m *PriceDataID) XXX_Size() int {
	return m.Size()
}
func (m *PriceDataID) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceDataID.DiscardUnknown(m)
}

var xxx_messageInfo_PriceDataID proto.InternalMessageInfo

func (m *PriceDataID) GetSource() uint32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *PriceDataID) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *PriceDataID) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

// PriceDataRecordID represents a price from a specific source at a specific time.
// It also represents a single data point in TWAP history
type PriceDataRecordID struct {
	// source is the index of the price source (oracle provider)
	Source uint32 `protobuf:"varint,1,opt,name=source,proto3" json:"source" yaml:"source"`
	// denom is the asset denomination
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom" yaml:"denom"`
	// base_denom is the base denomination for the price pair
	BaseDenom string `protobuf:"bytes,3,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom" yaml:"base_denom"`
	// height is the block height when this price was recorded
	Height int64 `protobuf:"varint,4,opt,name=height,proto3" json:"height" yaml:"height"`
}

func (m *PriceDataRecordID) Reset()         { *m = PriceDataRecordID{} }
func (m *PriceDataRecordID) String() string { return proto.CompactTextString(m) }
func (*PriceDataRecordID) ProtoMessage()    {}
func (*PriceDataRecordID) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{2}
}
func (m *PriceDataRecordID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceDataRecordID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceDataRecordID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceDataRecordID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceDataRecordID.Merge(m, src)
}
func (m *PriceDataRecordID) XXX_Size() int {
	return m.Size()
}
func (m *PriceDataRecordID) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceDataRecordID.DiscardUnknown(m)
}

var xxx_messageInfo_PriceDataRecordID proto.InternalMessageInfo

func (m *PriceDataRecordID) GetSource() uint32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *PriceDataRecordID) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *PriceDataRecordID) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

func (m *PriceDataRecordID) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

// PriceDataState represents the price value and timestamp for a price entry
type PriceDataState struct {
	// price is the decimal price value
	Price cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price" yaml:"price"`
	// timestamp is when the price was recorded
	Timestamp time.Time `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp" yaml:"timestamp"`
}

func (m *PriceDataState) Reset()         { *m = PriceDataState{} }
func (m *PriceDataState) String() string { return proto.CompactTextString(m) }
func (*PriceDataState) ProtoMessage()    {}
func (*PriceDataState) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{3}
}
func (m *PriceDataState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceDataState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceDataState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceDataState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceDataState.Merge(m, src)
}
func (m *PriceDataState) XXX_Size() int {
	return m.Size()
}
func (m *PriceDataState) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceDataState.DiscardUnknown(m)
}

var xxx_messageInfo_PriceDataState proto.InternalMessageInfo

func (m *PriceDataState) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

// PriceData combines a price record identifier with its state
type PriceData struct {
	// id uniquely identifies this price record
	ID PriceDataRecordID `protobuf:"bytes,1,opt,name=id,proto3" json:"id" yaml:"id"`
	// state contains the price value and timestamp
	State PriceDataState `protobuf:"bytes,2,opt,name=state,proto3" json:"state" yaml:"state"`
}

func (m *PriceData) Reset()         { *m = PriceData{} }
func (m *PriceData) String() string { return proto.CompactTextString(m) }
func (*PriceData) ProtoMessage()    {}
func (*PriceData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{4}
}
func (m *PriceData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceData.Merge(m, src)
}
func (m *PriceData) XXX_Size() int {
	return m.Size()
}
func (m *PriceData) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceData.DiscardUnknown(m)
}

var xxx_messageInfo_PriceData proto.InternalMessageInfo

func (m *PriceData) GetID() PriceDataRecordID {
	if m != nil {
		return m.ID
	}
	return PriceDataRecordID{}
}

func (m *PriceData) GetState() PriceDataState {
	if m != nil {
		return m.State
	}
	return PriceDataState{}
}

// AggregatedPrice represents the final aggregated price from all sources
type AggregatedPrice struct {
	// denom is the asset denomination
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom" yaml:"denom"`
	// twap is the time-weighted average price over the configured window
	TWAP cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=twap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"twap" yaml:"twap"`
	// median_price is the median of all source prices
	MedianPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=median_price,json=medianPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"median_price" yaml:"median_price"`
	// min_price is the minimum price from all sources
	MinPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=min_price,json=minPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price" yaml:"min_price"`
	// max_price is the maximum price from all sources
	MaxPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=max_price,json=maxPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_price" yaml:"max_price"`
	// timestamp is when the aggregated price was computed
	Timestamp time.Time `protobuf:"bytes,6,opt,name=timestamp,proto3,stdtime" json:"timestamp" yaml:"timestamp"`
	// num_sources is the number of price sources contributing to this aggregation
	NumSources uint32 `protobuf:"varint,7,opt,name=num_sources,json=numSources,proto3" json:"num_sources" yaml:"num_sources"`
	// deviation_bps is the price deviation in basis points between min and max prices
	DeviationBps uint64 `protobuf:"varint,8,opt,name=deviation_bps,json=deviationBps,proto3" json:"deviation_bps" yaml:"deviation_bps"`
}

func (m *AggregatedPrice) Reset()         { *m = AggregatedPrice{} }
func (m *AggregatedPrice) String() string { return proto.CompactTextString(m) }
func (*AggregatedPrice) ProtoMessage()    {}
func (*AggregatedPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{5}
}
func (m *AggregatedPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatedPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregatedPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregatedPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatedPrice.Merge(m, src)
}
func (m *AggregatedPrice) XXX_Size() int {
	return m.Size()
}
func (m *AggregatedPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatedPrice.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatedPrice proto.InternalMessageInfo

func (m *AggregatedPrice) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *AggregatedPrice) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *AggregatedPrice) GetNumSources() uint32 {
	if m != nil {
		return m.NumSources
	}
	return 0
}

func (m *AggregatedPrice) GetDeviationBps() uint64 {
	if m != nil {
		return m.DeviationBps
	}
	return 0
}

// PriceHealth represents the health status of a price feed
type PriceHealth struct {
	// denom is the asset denomination
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom" yaml:"denom"`
	// is_healthy indicates if the price feed meets all health requirements
	IsHealthy bool `protobuf:"varint,3,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	// has_min_sources indicates if minimum number of sources are reporting
	HasMinSources bool `protobuf:"varint,4,opt,name=has_min_sources,json=hasMinSources,proto3" json:"has_min_sources,omitempty"`
	// deviation_ok indicates if price deviation is within acceptable limits
	DeviationOk bool `protobuf:"varint,5,opt,name=deviation_ok,json=deviationOk,proto3" json:"deviation_ok,omitempty"`
	// all_sources_fresh indicates if all source prices are not stale
	AllSourcesFresh bool `protobuf:"varint,6,opt,name=all_sources_fresh,json=allSourcesFresh,proto3" json:"all_sources_fresh,omitempty"`
	// failure_reason lists reasons for unhealthy status, if any
	FailureReason []string `protobuf:"bytes,7,rep,name=failure_reason,json=failureReason,proto3" json:"failure_reason,omitempty"`
}

func (m *PriceHealth) Reset()         { *m = PriceHealth{} }
func (m *PriceHealth) String() string { return proto.CompactTextString(m) }
func (*PriceHealth) ProtoMessage()    {}
func (*PriceHealth) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{6}
}
func (m *PriceHealth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceHealth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceHealth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceHealth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceHealth.Merge(m, src)
}
func (m *PriceHealth) XXX_Size() int {
	return m.Size()
}
func (m *PriceHealth) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceHealth.DiscardUnknown(m)
}

var xxx_messageInfo_PriceHealth proto.InternalMessageInfo

func (m *PriceHealth) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *PriceHealth) GetIsHealthy() bool {
	if m != nil {
		return m.IsHealthy
	}
	return false
}

func (m *PriceHealth) GetHasMinSources() bool {
	if m != nil {
		return m.HasMinSources
	}
	return false
}

func (m *PriceHealth) GetDeviationOk() bool {
	if m != nil {
		return m.DeviationOk
	}
	return false
}

func (m *PriceHealth) GetAllSourcesFresh() bool {
	if m != nil {
		return m.AllSourcesFresh
	}
	return false
}

func (m *PriceHealth) GetFailureReason() []string {
	if m != nil {
		return m.FailureReason
	}
	return nil
}

// PricesFilter defines filters used to query price data
type PricesFilter struct {
	// asset_denom is the asset denomination to filter by
	AssetDenom string `protobuf:"bytes,1,opt,name=asset_denom,json=assetDenom,proto3" json:"asset_denom" yaml:"asset_denom"`
	// base_denom is the base denomination to filter by
	BaseDenom string `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom" yaml:"base_denom"`
	// height is the block height to filter by
	Height int64 `protobuf:"varint,3,opt,name=height,proto3" json:"height" yaml:"height"`
}

func (m *PricesFilter) Reset()         { *m = PricesFilter{} }
func (m *PricesFilter) String() string { return proto.CompactTextString(m) }
func (*PricesFilter) ProtoMessage()    {}
func (*PricesFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{7}
}
func (m *PricesFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PricesFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PricesFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PricesFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PricesFilter.Merge(m, src)
}
func (m *PricesFilter) XXX_Size() int {
	return m.Size()
}
func (m *PricesFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PricesFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PricesFilter proto.InternalMessageInfo

func (m *PricesFilter) GetAssetDenom() string {
	if m != nil {
		return m.AssetDenom
	}
	return ""
}

func (m *PricesFilter) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

func (m *PricesFilter) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

// QueryPricesRequest is the request type for querying price history
type QueryPricesRequest struct {
	// filters holds the price fields to filter the request
	Filters PricesFilter `protobuf:"bytes,1,opt,name=filters,proto3" json:"filters"`
	// pagination is used to paginate the request
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryPricesRequest) Reset()         { *m = QueryPricesRequest{} }
func (m *QueryPricesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPricesRequest) ProtoMessage()    {}
func (*QueryPricesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{8}
}
func (m *QueryPricesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPricesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPricesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPricesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPricesRequest.Merge(m, src)
}
func (m *QueryPricesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPricesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPricesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPricesRequest proto.InternalMessageInfo

func (m *QueryPricesRequest) GetFilters() PricesFilter {
	if m != nil {
		return m.Filters
	}
	return PricesFilter{}
}

func (m *QueryPricesRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryPricesResponse is the response type for querying price history
type QueryPricesResponse struct {
	// prices is the list of historical price data matching the filters
	Prices []PriceData `protobuf:"bytes,1,rep,name=prices,proto3" json:"prices" yaml:"prices"`
	// pagination contains the information about response pagination
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryPricesResponse) Reset()         { *m = QueryPricesResponse{} }
func (m *QueryPricesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPricesResponse) ProtoMessage()    {}
func (*QueryPricesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c3bb3f3061bb41c, []int{9}
}
func (m *QueryPricesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPricesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPricesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPricesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPricesResponse.Merge(m, src)
}
func (m *QueryPricesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPricesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPricesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPricesResponse proto.InternalMessageInfo

func (m *QueryPricesResponse) GetPrices() []PriceData {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *QueryPricesResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func init() {
	proto.RegisterType((*DataID)(nil), "akash.oracle.v1.DataID")
	proto.RegisterType((*PriceDataID)(nil), "akash.oracle.v1.PriceDataID")
	proto.RegisterType((*PriceDataRecordID)(nil), "akash.oracle.v1.PriceDataRecordID")
	proto.RegisterType((*PriceDataState)(nil), "akash.oracle.v1.PriceDataState")
	proto.RegisterType((*PriceData)(nil), "akash.oracle.v1.PriceData")
	proto.RegisterType((*AggregatedPrice)(nil), "akash.oracle.v1.AggregatedPrice")
	proto.RegisterType((*PriceHealth)(nil), "akash.oracle.v1.PriceHealth")
	proto.RegisterType((*PricesFilter)(nil), "akash.oracle.v1.PricesFilter")
	proto.RegisterType((*QueryPricesRequest)(nil), "akash.oracle.v1.QueryPricesRequest")
	proto.RegisterType((*QueryPricesResponse)(nil), "akash.oracle.v1.QueryPricesResponse")
}

func init() { proto.RegisterFile("akash/oracle/v1/prices.proto", fileDescriptor_8c3bb3f3061bb41c) }

var fileDescriptor_8c3bb3f3061bb41c = []byte{
	// 1068 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x41, 0x6b, 0x1b, 0xc7,
	0x17, 0xf7, 0x4a, 0xb2, 0x2d, 0x8d, 0xec, 0x38, 0xde, 0xe4, 0xa0, 0x38, 0x7f, 0x6b, 0xfc, 0x9f,
	0x92, 0xd4, 0x35, 0x74, 0x17, 0x27, 0xd0, 0x42, 0xa0, 0x87, 0x08, 0xe1, 0x36, 0xa1, 0x69, 0x9d,
	0xb1, 0xa1, 0x50, 0x0a, 0xcb, 0x58, 0x3b, 0x5e, 0x0d, 0xd2, 0xee, 0x6c, 0x76, 0x56, 0x4e, 0x7c,
	0xe8, 0xa1, 0xdf, 0x20, 0xf7, 0x5e, 0x7a, 0xec, 0xb1, 0xd0, 0x40, 0xbf, 0x42, 0x8e, 0xa1, 0x50,
	0x28, 0x3d, 0x4c, 0x83, 0x7d, 0x68, 0xd1, 0x71, 0xfb, 0x05, 0xca, 0xce, 0x8c, 0xb4, 0x9b, 0x46,
	0xa6, 0x8e, 0x29, 0x85, 0x5e, 0x84, 0xde, 0x6f, 0xe6, 0xbd, 0xf7, 0x7b, 0x6f, 0x7e, 0xf3, 0x76,
	0xc0, 0xff, 0xc8, 0x80, 0x88, 0xbe, 0xcb, 0x13, 0xd2, 0x1b, 0x52, 0xf7, 0x68, 0xdb, 0x8d, 0x13,
	0xd6, 0xa3, 0xc2, 0x89, 0x13, 0x9e, 0x72, 0x7b, 0x45, 0xad, 0x3a, 0x7a, 0xd5, 0x39, 0xda, 0x5e,
	0x5b, 0x25, 0x21, 0x8b, 0xb8, 0xab, 0x7e, 0xf5, 0x9e, 0xb5, 0xad, 0x1e, 0x17, 0x21, 0x17, 0xee,
	0x01, 0x11, 0xd4, 0x7d, 0x34, 0xa2, 0xc9, 0xb1, 0x7b, 0xb4, 0x7d, 0x40, 0x53, 0xb2, 0xed, 0xc6,
	0x24, 0x60, 0x11, 0x49, 0x19, 0x8f, 0xcc, 0xde, 0x6b, 0x7a, 0xaf, 0xa7, 0x2c, 0x57, 0x1b, 0x66,
	0xe9, 0x6a, 0xc0, 0x03, 0xae, 0xf1, 0xfc, 0x9f, 0x41, 0x61, 0xc0, 0x79, 0x30, 0xa4, 0xae, 0xb2,
	0x0e, 0x46, 0x87, 0x6e, 0xca, 0x42, 0x2a, 0x52, 0x12, 0xc6, 0x7a, 0x03, 0xfa, 0x12, 0x2c, 0x74,
	0x49, 0x4a, 0xee, 0x75, 0x6d, 0x17, 0xcc, 0xfb, 0x34, 0xe2, 0x61, 0xcb, 0xda, 0xb0, 0x36, 0x1b,
	0x9d, 0x6b, 0x63, 0x09, 0x35, 0x90, 0x49, 0xb8, 0x74, 0x4c, 0xc2, 0xe1, 0x1d, 0xa4, 0x4c, 0x84,
	0x35, 0x6c, 0x77, 0x00, 0xc8, 0x39, 0x7b, 0xda, 0xab, 0xa2, 0xbc, 0xde, 0x1a, 0x4b, 0x58, 0x42,
	0x33, 0x09, 0x57, 0xb5, 0x6b, 0x81, 0x21, 0xdc, 0xc8, 0x8d, 0xae, 0xfa, 0xff, 0x83, 0x05, 0x9a,
	0xbb, 0x79, 0xc7, 0x0c, 0x89, 0xdb, 0x60, 0x41, 0xf0, 0x51, 0xd2, 0xa3, 0x8a, 0xc5, 0x72, 0xe7,
	0xfa, 0x58, 0x42, 0x83, 0x64, 0x12, 0x2e, 0xeb, 0x58, 0xda, 0x46, 0xd8, 0x2c, 0x14, 0xcc, 0x2b,
	0x17, 0x62, 0x5e, 0xbd, 0x10, 0xf3, 0xcc, 0x02, 0xab, 0x53, 0xe6, 0x98, 0xf6, 0x78, 0xe2, 0xff,
	0x97, 0xf8, 0xe7, 0x4c, 0xfb, 0x94, 0x05, 0xfd, 0xb4, 0x55, 0xdb, 0xb0, 0x36, 0xab, 0x9a, 0xa9,
	0x46, 0x0a, 0xa6, 0xda, 0x46, 0xd8, 0x2c, 0xa0, 0x97, 0x16, 0xb8, 0x34, 0x2d, 0x7a, 0x2f, 0x25,
	0x29, 0xb5, 0xbf, 0x00, 0xf3, 0x4a, 0xf2, 0x46, 0x36, 0x3b, 0xcf, 0x25, 0x9c, 0xfb, 0x45, 0xc2,
	0xeb, 0x5a, 0x9c, 0xc2, 0x1f, 0x38, 0x8c, 0xbb, 0x21, 0x49, 0xfb, 0xce, 0xc7, 0x34, 0x20, 0xbd,
	0xe3, 0x2e, 0xed, 0x15, 0x65, 0x29, 0x4f, 0xf4, 0xe3, 0xb3, 0x77, 0x81, 0xd1, 0x72, 0x97, 0xf6,
	0xbe, 0xfd, 0xed, 0xbb, 0x2d, 0x0b, 0xeb, 0xa0, 0x76, 0x0c, 0x1a, 0x53, 0xc5, 0xaa, 0xf6, 0x34,
	0x6f, 0xad, 0x39, 0x5a, 0xd3, 0xce, 0x44, 0xd3, 0xce, 0xfe, 0x64, 0x47, 0xe7, 0xbd, 0x3c, 0xfb,
	0x89, 0x84, 0x8d, 0x29, 0x34, 0x96, 0xb0, 0x88, 0x90, 0x49, 0x78, 0x59, 0x27, 0x9e, 0x42, 0xe8,
	0xe9, 0xaf, 0xd0, 0xc2, 0xc5, 0x16, 0xf4, 0xcc, 0x02, 0x8d, 0x69, 0x89, 0xf6, 0x43, 0x50, 0x61,
	0xbe, 0x2a, 0xad, 0x79, 0x0b, 0x39, 0x7f, 0xb9, 0xcd, 0xce, 0x6b, 0xe7, 0xdf, 0x59, 0x37, 0x04,
	0x2a, 0xf7, 0xba, 0x63, 0x09, 0x2b, 0xcc, 0xcf, 0x24, 0x6c, 0xe8, 0x94, 0xcc, 0x47, 0xb8, 0xc2,
	0x7c, 0x7b, 0x1f, 0xcc, 0x8b, 0xbc, 0x73, 0xa6, 0x1c, 0x78, 0x76, 0x54, 0xd5, 0x60, 0x1d, 0x32,
	0x97, 0x84, 0xf2, 0x2a, 0x7a, 0xa7, 0x4c, 0x84, 0x35, 0x8c, 0xfe, 0x98, 0x07, 0x2b, 0x77, 0x83,
	0x20, 0xa1, 0x01, 0x49, 0xa9, 0xaf, 0x42, 0xbc, 0xf9, 0x8d, 0x26, 0xa0, 0x96, 0x3e, 0x26, 0xb1,
	0xd1, 0xe1, 0x83, 0x73, 0x1c, 0xe5, 0x89, 0x84, 0xb5, 0xfd, 0xcf, 0xee, 0xee, 0x66, 0x12, 0x36,
	0x4d, 0x67, 0x1f, 0x93, 0x78, 0xe6, 0x89, 0xaa, 0xd0, 0x76, 0x0c, 0x96, 0x42, 0xea, 0x33, 0x12,
	0x79, 0x5a, 0x35, 0xd5, 0x73, 0xa7, 0xca, 0x24, 0xbc, 0xa2, 0x53, 0x94, 0x03, 0xcc, 0x4c, 0xd5,
	0xd4, 0x3b, 0x74, 0x17, 0x02, 0xd0, 0x08, 0xd9, 0x24, 0x5d, 0x4d, 0xa5, 0xbb, 0x7f, 0xbe, 0x74,
	0x46, 0x2b, 0x53, 0xef, 0x99, 0xb9, 0xea, 0x21, 0x2b, 0x25, 0x22, 0x4f, 0x4c, 0xa2, 0xf9, 0x8b,
	0x24, 0x9a, 0x78, 0x9f, 0x91, 0x88, 0x3c, 0xd9, 0x7d, 0xfd, 0x52, 0x2c, 0xfc, 0x0b, 0x97, 0xc2,
	0xde, 0x01, 0xcd, 0x68, 0x14, 0x7a, 0x7a, 0x5e, 0x89, 0xd6, 0xa2, 0x9a, 0x6d, 0x37, 0xc6, 0x12,
	0x96, 0xe1, 0x4c, 0x42, 0x5b, 0x07, 0x2a, 0x81, 0x08, 0x83, 0x68, 0x14, 0xee, 0x69, 0xc3, 0xfe,
	0x04, 0x2c, 0xfb, 0xf4, 0x88, 0xa9, 0x4f, 0x9a, 0x77, 0x10, 0x8b, 0x56, 0x7d, 0xc3, 0xda, 0xac,
	0x75, 0xde, 0x19, 0x4b, 0xf8, 0xea, 0x42, 0x26, 0xe1, 0xd5, 0x89, 0x42, 0x4b, 0x30, 0xc2, 0x4b,
	0x53, 0xbb, 0x13, 0x0b, 0xf4, 0x55, 0xc5, 0x7c, 0x3e, 0x3e, 0xa2, 0x64, 0x98, 0xf6, 0xdf, 0x5c,
	0xf1, 0xeb, 0x00, 0x30, 0xe1, 0xf5, 0x95, 0xf7, 0xb1, 0x12, 0x63, 0x1d, 0x37, 0x98, 0xd0, 0xe1,
	0x8e, 0xed, 0x9b, 0x60, 0xa5, 0x4f, 0x84, 0x97, 0x2b, 0x60, 0x52, 0x7b, 0x4d, 0xed, 0x59, 0xee,
	0x13, 0xf1, 0x80, 0x45, 0x93, 0xba, 0xfe, 0x0f, 0x0a, 0x5e, 0x1e, 0x1f, 0xa8, 0xd3, 0xaf, 0xe3,
	0xe6, 0x14, 0xfb, 0x74, 0x60, 0x6f, 0x81, 0x55, 0x32, 0x1c, 0x4e, 0xc2, 0x78, 0x87, 0x09, 0x15,
	0x7d, 0x75, 0x78, 0x75, 0xbc, 0x42, 0x86, 0x43, 0x13, 0x69, 0x27, 0x87, 0xed, 0x1b, 0xe0, 0xd2,
	0x21, 0x61, 0xc3, 0x51, 0x42, 0xbd, 0x84, 0x12, 0xc1, 0xa3, 0xd6, 0xe2, 0x46, 0x75, 0xb3, 0x81,
	0x97, 0x0d, 0x8a, 0x15, 0x78, 0xbf, 0x56, 0xaf, 0x5c, 0xae, 0xa2, 0x9f, 0x2c, 0xb0, 0xa4, 0x7a,
	0x20, 0x76, 0xd8, 0x30, 0xa5, 0x49, 0x7e, 0x58, 0x44, 0x08, 0x9a, 0x7a, 0xe5, 0x56, 0xa8, 0xc3,
	0x2a, 0xc1, 0xc5, 0x61, 0x95, 0x40, 0x84, 0x81, 0xb2, 0xba, 0xff, 0xd4, 0xf7, 0xbd, 0xf4, 0x95,
	0xa9, 0x9e, 0xfb, 0x2b, 0x73, 0xa7, 0xf6, 0xfb, 0x37, 0x70, 0x0e, 0x7d, 0x6d, 0x01, 0xfb, 0x61,
	0xfe, 0x1c, 0xd2, 0xc5, 0x61, 0xfa, 0x68, 0x44, 0x45, 0x6a, 0x7f, 0x00, 0x16, 0x0f, 0x55, 0x9d,
	0xc2, 0x8c, 0xe5, 0xf5, 0xd9, 0x03, 0xd4, 0x74, 0xa3, 0x53, 0xcb, 0xd5, 0x8f, 0x27, 0x3e, 0xf6,
	0x0e, 0x00, 0xc5, 0xab, 0xca, 0x8c, 0xe0, 0x9b, 0x8e, 0xb9, 0x6b, 0x39, 0x6f, 0x47, 0x3d, 0xc1,
	0x1c, 0xf3, 0x04, 0x73, 0x76, 0x49, 0x40, 0x4d, 0x6a, 0x5c, 0xf2, 0x44, 0xdf, 0x5b, 0xe0, 0xca,
	0x2b, 0xec, 0x44, 0xcc, 0x23, 0x41, 0xed, 0x3d, 0xb0, 0xa0, 0x5f, 0x80, 0x2d, 0x6b, 0xa3, 0xaa,
	0x2e, 0xe6, 0x99, 0xe3, 0xbd, 0x03, 0xcd, 0x64, 0x37, 0x1e, 0x45, 0x43, 0xb4, 0x8d, 0xb0, 0x59,
	0xb0, 0x3f, 0x9c, 0x41, 0xfa, 0xed, 0xbf, 0x25, 0xad, 0x19, 0x95, 0x59, 0x77, 0xde, 0x7f, 0x7e,
	0xd2, 0xb6, 0x5e, 0x9c, 0xb4, 0xad, 0x97, 0x27, 0x6d, 0xeb, 0xe9, 0x69, 0x7b, 0xee, 0xc5, 0x69,
	0x7b, 0xee, 0xe7, 0xd3, 0xf6, 0xdc, 0xe7, 0xeb, 0xf1, 0x20, 0x70, 0xc8, 0x20, 0x75, 0x7c, 0x7a,
	0xe4, 0x06, 0xdc, 0x8d, 0xb8, 0x4f, 0x8b, 0x57, 0xed, 0xc1, 0x82, 0x9a, 0x2b, 0xb7, 0xff, 0x0c,
	0x00, 0x00, 0xff, 0xff, 0xa9, 0x61, 0xc6, 0x8f, 0xef, 0x0a, 0x00, 0x00,
}

func (m *DataID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceDataID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceDataID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceDataID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Source != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceDataRecordID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceDataRecordID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceDataRecordID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Source != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceDataState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceDataState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceDataState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintPrices(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x12
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PriceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AggregatedPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatedPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregatedPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviationBps != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.DeviationBps))
		i--
		dAtA[i] = 0x40
	}
	if m.NumSources != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.NumSources))
		i--
		dAtA[i] = 0x38
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintPrices(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxPrice.Size()
		i -= size
		if _, err := m.MaxPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinPrice.Size()
		i -= size
		if _, err := m.MinPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.MedianPrice.Size()
		i -= size
		if _, err := m.MedianPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TWAP.Size()
		i -= size
		if _, err := m.TWAP.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceHealth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceHealth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceHealth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailureReason) > 0 {
		for iNdEx := len(m.FailureReason) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailureReason[iNdEx])
			copy(dAtA[i:], m.FailureReason[iNdEx])
			i = encodeVarintPrices(dAtA, i, uint64(len(m.FailureReason[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.AllSourcesFresh {
		i--
		if m.AllSourcesFresh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DeviationOk {
		i--
		if m.DeviationOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.HasMinSources {
		i--
		if m.HasMinSources {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsHealthy {
		i--
		if m.IsHealthy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PricesFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PricesFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PricesFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintPrices(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AssetDenom) > 0 {
		i -= len(m.AssetDenom)
		copy(dAtA[i:], m.AssetDenom)
		i = encodeVarintPrices(dAtA, i, uint64(len(m.AssetDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPricesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPricesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPricesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Filters.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrices(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryPricesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPricesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPricesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Prices) > 0 {
		for iNdEx := len(m.Prices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPrices(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPrices(dAtA []byte, offset int, v uint64) int {
	offset -= sovPrices(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func (m *PriceDataID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovPrices(uint64(m.Source))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func (m *PriceDataRecordID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovPrices(uint64(m.Source))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovPrices(uint64(m.Height))
	}
	return n
}

func (m *PriceDataState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Price.Size()
	n += 1 + l + sovPrices(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovPrices(uint64(l))
	return n
}

func (m *PriceData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovPrices(uint64(l))
	l = m.State.Size()
	n += 1 + l + sovPrices(uint64(l))
	return n
}

func (m *AggregatedPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = m.TWAP.Size()
	n += 1 + l + sovPrices(uint64(l))
	l = m.MedianPrice.Size()
	n += 1 + l + sovPrices(uint64(l))
	l = m.MinPrice.Size()
	n += 1 + l + sovPrices(uint64(l))
	l = m.MaxPrice.Size()
	n += 1 + l + sovPrices(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovPrices(uint64(l))
	if m.NumSources != 0 {
		n += 1 + sovPrices(uint64(m.NumSources))
	}
	if m.DeviationBps != 0 {
		n += 1 + sovPrices(uint64(m.DeviationBps))
	}
	return n
}

func (m *PriceHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	if m.IsHealthy {
		n += 2
	}
	if m.HasMinSources {
		n += 2
	}
	if m.DeviationOk {
		n += 2
	}
	if m.AllSourcesFresh {
		n += 2
	}
	if len(m.FailureReason) > 0 {
		for _, s := range m.FailureReason {
			l = len(s)
			n += 1 + l + sovPrices(uint64(l))
		}
	}
	return n
}

func (m *PricesFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetDenom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovPrices(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovPrices(uint64(m.Height))
	}
	return n
}

func (m *QueryPricesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Filters.Size()
	n += 1 + l + sovPrices(uint64(l))
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func (m *QueryPricesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prices) > 0 {
		for _, e := range m.Prices {
			l = e.Size()
			n += 1 + l + sovPrices(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovPrices(uint64(l))
	}
	return n
}

func sovPrices(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPrices(x uint64) (n int) {
	return sovPrices(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceDataID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceDataID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceDataID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceDataRecordID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceDataRecordID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceDataRecordID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceDataState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceDataState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceDataState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatedPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatedPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatedPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TWAP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TWAP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MedianPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSources", wireType)
			}
			m.NumSources = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSources |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviationBps", wireType)
			}
			m.DeviationBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviationBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceHealth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceHealth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceHealth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHealthy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHealthy = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMinSources", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMinSources = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviationOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviationOk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllSourcesFresh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllSourcesFresh = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureReason = append(m.FailureReason, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricesFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricesFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricesFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPricesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPricesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPricesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPricesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPricesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPricesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prices = append(m.Prices, PriceData{})
			if err := m.Prices[len(m.Prices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrices(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrices
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPrices
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPrices
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPrices
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPrices        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrices          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPrices = fmt.Errorf("proto: unexpected end of group")
)
