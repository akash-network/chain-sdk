// DO NOT EDIT THIS FILE
// This file is generated by the script/compile-json-schema-to-ts.ts script
// It is used to validate the JWT schema

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

export const schema = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://raw.githubusercontent.com/akash-network/chain-sdk/refs/heads/main/specs/jwt-schema.json",
  title: "Akash JWT Schema",
  description: "JSON Schema for JWT used in the Akash Provider API.",
  type: "object",
  additionalProperties: false,
  required: [
    "iss",
    "iat",
    "exp",
    "nbf",
    "version",
    "leases",
  ],
  properties: {
    iss: {
      type: "string",
      pattern: "^akash1[a-z0-9]{38}$",
      description: "Akash address of the lease(s) owner, e.g., akash1abcd... (44 characters)",
    },
    iat: {
      type: "integer",
      minimum: 0,
      description: "Token issuance timestamp as Unix time (seconds since 1970-01-01T00:00:00Z). Should be <= exp and >= nbf.",
    },
    nbf: {
      type: "integer",
      minimum: 0,
      description: "Not valid before timestamp as Unix time (seconds since 1970-01-01T00:00:00Z). Should be <= iat.",
    },
    exp: {
      type: "integer",
      minimum: 0,
      description: "Expiration timestamp as Unix time (seconds since 1970-01-01T00:00:00Z). Should be >= iat.",
    },
    jti: {
      type: "string",
      minLength: 1,
      description: "Unique identifier for the JWT, used to prevent token reuse.",
    },
    version: {
      type: "string",
      enum: [
        "v1",
      ],
      description: "Version of the JWT specification (currently fixed at v1).",
    },
    leases: {
      type: "object",
      additionalProperties: false,
      required: [
        "access",
      ],
      properties: {
        access: {
          type: "string",
          enum: [
            "full",
            "granular",
            "scoped",
          ],
          description: "Access level for the lease: 'full' for unrestricted access to all actions, 'scoped' for specific actions across all provider leases,'granular' for provider-specific permissions.",
        },
        scope: {
          type: "array",
          minItems: 1,
          uniqueItems: true,
          items: {
            type: "string",
            enum: [
              "send-manifest",
              "get-manifest",
              "logs",
              "shell",
              "events",
              "status",
              "restart",
              "hostname-migrate",
              "ip-migrate",
            ],
          },
          description: "Global list of permitted actions across all owned leases (no duplicates). Required when access is 'scoped'.",
        },
        permissions: {
          type: "array",
          description: "Required if leases.access is 'granular'; defines provider-specific permissions. The provider address must be unique across all permissions entries.",
          minItems: 1,
          items: {
            type: "object",
            additionalProperties: false,
            required: [
              "provider",
              "access",
            ],
            properties: {
              provider: {
                type: "string",
                pattern: "^akash1[a-z0-9]{38}$",
                description: "Provider address, e.g., akash1xyz... (44 characters).",
              },
              access: {
                type: "string",
                enum: [
                  "full",
                  "scoped",
                  "granular",
                ],
                description: "Provider-level access: 'full' for all actions, 'scoped' for specific actions across all provider leases, 'granular' for deployment-specific actions.",
              },
              scope: {
                type: "array",
                minItems: 1,
                uniqueItems: true,
                items: {
                  type: "string",
                  enum: [
                    "send-manifest",
                    "get-manifest",
                    "logs",
                    "shell",
                    "events",
                    "status",
                    "restart",
                    "hostname-migrate",
                    "ip-migrate",
                  ],
                },
                description: "Provider-level list of permitted actions for 'scoped' access (no duplicates).",
              },
              deployments: {
                type: "array",
                minItems: 1,
                items: {
                  type: "object",
                  additionalProperties: false,
                  required: [
                    "dseq",
                    "scope",
                    "services",
                  ],
                  properties: {
                    dseq: {
                      type: "integer",
                      minimum: 1,
                      description: "Deployment sequence number.",
                    },
                    scope: {
                      type: "array",
                      minItems: 1,
                      uniqueItems: true,
                      items: {
                        type: "string",
                        enum: [
                          "send-manifest",
                          "get-manifest",
                          "logs",
                          "shell",
                          "events",
                          "status",
                          "restart",
                          "hostname-migrate",
                          "ip-migrate",
                        ],
                      },
                      description: "Deployment-level list of permitted actions (no duplicates).",
                    },
                    gseq: {
                      type: "integer",
                      minimum: 0,
                      description: "Group sequence number (requires dseq).",
                    },
                    oseq: {
                      type: "integer",
                      minimum: 0,
                      description: "Order sequence number (requires dseq and gseq).",
                    },
                    services: {
                      type: "array",
                      minItems: 1,
                      uniqueItems: true,
                      items: {
                        type: "string",
                        minLength: 1,
                      },
                      description: "List of service names (requires dseq).",
                    },
                  },
                  dependencies: {
                    gseq: [
                      "dseq",
                    ],
                    oseq: [
                      "dseq",
                      "gseq",
                    ],
                    services: [
                      "dseq",
                    ],
                  },
                },
              },
            },
            allOf: [
              {
                if: {
                  properties: {
                    access: {
                      const: "scoped",
                    },
                  },
                },
                then: {
                  required: [
                    "scope",
                  ],
                  properties: {
                    scope: {
                      minItems: 1,
                    },
                    deployments: false,
                  },
                },
              },
              {
                if: {
                  properties: {
                    access: {
                      const: "granular",
                    },
                  },
                },
                then: {
                  required: [
                    "deployments",
                  ],
                  properties: {
                    scope: false,
                  },
                },
              },
              {
                if: {
                  properties: {
                    access: {
                      const: "full",
                    },
                  },
                },
                then: {
                  properties: {
                    scope: false,
                    deployments: false,
                  },
                },
              },
            ],
          },
        },
      },
      allOf: [
        {
          if: {
            properties: {
              access: {
                const: "full",
              },
            },
          },
          then: {
            properties: {
              permissions: false,
              scope: false,
            },
          },
        },
        {
          if: {
            properties: {
              access: {
                const: "scoped",
              },
            },
          },
          then: {
            required: [
              "scope",
            ],
            properties: {
              scope: {
                minItems: 1,
              },
              permissions: false,
            },
          },
        },
        {
          if: {
            properties: {
              access: {
                const: "granular",
              },
            },
            required: [
              "access",
            ],
          },
          then: {
            required: [
              "permissions",
            ],
            properties: {
              scope: false,
            },
          },
        },
      ],
    },
  },
  allOf: [
    {
      if: {
        properties: {
          leases: {
            properties: {
              access: {
                const: "granular",
              },
            },
            required: [
              "access",
            ],
          },
        },
        required: [
          "leases",
        ],
      },
      then: {
        properties: {
          leases: {
            required: [
              "permissions",
            ],
            properties: {
              scope: false,
            },
          },
        },
      },
    },
    {
      if: {
        properties: {
          leases: {
            properties: {
              permissions: {
                type: "array",
                minItems: 1,
              },
            },
            required: [
              "permissions",
            ],
          },
        },
        required: [
          "leases",
        ],
      },
      then: {
        properties: {
          leases: {
            properties: {
              access: {
                const: "granular",
              },
            },
            required: [
              "access",
            ],
          },
        },
      },
    },
  ],
};
export const validate = (function () {
  "use strict";
  const hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  const pattern0 = new RegExp("^akash1[a-z0-9]{38}$", "u");
  const stringLength = (string) =>
    /[\uD800-\uDFFF]/.test(string) ? [...string].length : string.length;
  const unique = (array) => {
    if (array.length < 2) return true;
    if (array.length === 2) return !deepEqual(array[0], array[1]);
    const objects = [];
    const primitives = array.length > 20 ? new Set() : null;
    let primitivesCount = 0;
    let pos = 0;
    for (const item of array) {
      if (typeof item === "object") {
        objects.push(item);
      } else if (primitives) {
        primitives.add(item);
        if (primitives.size !== ++primitivesCount) return false;
      } else {
        if (array.indexOf(item, pos + 1) !== -1) return false;
      }
      pos++;
    }
    for (let i = 1; i < objects.length; i++)
      for (let j = 0; j < i; j++) if (deepEqual(objects[i], objects[j])) return false;
    return true;
  };
  const deepEqual = (obj, obj2) => {
    if (obj === obj2) return true;
    if (!obj || !obj2 || typeof obj !== typeof obj2) return false;
    if (obj !== obj2 && typeof obj !== "object") return false;

    const proto = Object.getPrototypeOf(obj);
    if (proto !== Object.getPrototypeOf(obj2)) return false;

    if (proto === Array.prototype) {
      if (!Array.isArray(obj) || !Array.isArray(obj2)) return false;
      if (obj.length !== obj2.length) return false;
      return obj.every((x, i) => deepEqual(x, obj2[i]));
    } else if (proto === Object.prototype) {
      const [keys, keys2] = [Object.keys(obj), Object.keys(obj2)];
      if (keys.length !== keys2.length) return false;
      const keyset2 = new Set([...keys, ...keys2]);
      return keyset2.size === keys.length && keys.every((key) => deepEqual(obj[key], obj2[key]));
    }
    return false;
  };
  const pointerPart = (s) => (/~\//.test(s) ? `${s}`.replace(/~/g, "~0").replace(/\//g, "~1") : s);
  const ref0 = function validate(data) {
    validate.errors = null;
    let errorCount = 0;
    if (!(typeof data === "object" && data && !Array.isArray(data))) {
      if (validate.errors === null) validate.errors = [];
      validate.errors.push({ keywordLocation: "#/type", instanceLocation: "#" });
      errorCount++;
    } else {
      if (!("iss" in data && hasOwn(data, "iss"))) {
        if (validate.errors === null) validate.errors = [];
        validate.errors.push({ keywordLocation: "#/required", instanceLocation: "#/iss" });
        errorCount++;
      }
      if (!("iat" in data && hasOwn(data, "iat"))) {
        if (validate.errors === null) validate.errors = [];
        validate.errors.push({ keywordLocation: "#/required", instanceLocation: "#/iat" });
        errorCount++;
      }
      if (!("exp" in data && hasOwn(data, "exp"))) {
        if (validate.errors === null) validate.errors = [];
        validate.errors.push({ keywordLocation: "#/required", instanceLocation: "#/exp" });
        errorCount++;
      }
      if (!("nbf" in data && hasOwn(data, "nbf"))) {
        if (validate.errors === null) validate.errors = [];
        validate.errors.push({ keywordLocation: "#/required", instanceLocation: "#/nbf" });
        errorCount++;
      }
      if (!("version" in data && hasOwn(data, "version"))) {
        if (validate.errors === null) validate.errors = [];
        validate.errors.push({ keywordLocation: "#/required", instanceLocation: "#/version" });
        errorCount++;
      }
      if (!("leases" in data && hasOwn(data, "leases"))) {
        if (validate.errors === null) validate.errors = [];
        validate.errors.push({ keywordLocation: "#/required", instanceLocation: "#/leases" });
        errorCount++;
      }
      if ("iss" in data && hasOwn(data, "iss")) {
        if (!(typeof data.iss === "string")) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/iss/type", instanceLocation: "#/iss" });
          errorCount++;
        } else {
          const prev0 = errorCount;
          if (errorCount === prev0) {
            if (!pattern0.test(data.iss)) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/iss/pattern", instanceLocation: "#/iss" });
              errorCount++;
            }
          }
        }
      }
      if ("iat" in data && hasOwn(data, "iat")) {
        if (!Number.isInteger(data.iat)) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/iat/type", instanceLocation: "#/iat" });
          errorCount++;
        } else {
          if (!(0 <= data.iat)) {
            if (validate.errors === null) validate.errors = [];
            validate.errors.push({ keywordLocation: "#/properties/iat/minimum", instanceLocation: "#/iat" });
            errorCount++;
          }
        }
      }
      if ("nbf" in data && hasOwn(data, "nbf")) {
        if (!Number.isInteger(data.nbf)) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/nbf/type", instanceLocation: "#/nbf" });
          errorCount++;
        } else {
          if (!(0 <= data.nbf)) {
            if (validate.errors === null) validate.errors = [];
            validate.errors.push({ keywordLocation: "#/properties/nbf/minimum", instanceLocation: "#/nbf" });
            errorCount++;
          }
        }
      }
      if ("exp" in data && hasOwn(data, "exp")) {
        if (!Number.isInteger(data.exp)) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/exp/type", instanceLocation: "#/exp" });
          errorCount++;
        } else {
          if (!(0 <= data.exp)) {
            if (validate.errors === null) validate.errors = [];
            validate.errors.push({ keywordLocation: "#/properties/exp/minimum", instanceLocation: "#/exp" });
            errorCount++;
          }
        }
      }
      if ("jti" in data && hasOwn(data, "jti")) {
        if (!(typeof data.jti === "string")) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/jti/type", instanceLocation: "#/jti" });
          errorCount++;
        } else {
          if (data.jti.length < 1 || stringLength(data.jti) < 1) {
            if (validate.errors === null) validate.errors = [];
            validate.errors.push({ keywordLocation: "#/properties/jti/minLength", instanceLocation: "#/jti" });
            errorCount++;
          }
        }
      }
      if ("version" in data && hasOwn(data, "version")) {
        if (!(typeof data.version === "string")) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/version/type", instanceLocation: "#/version" });
          errorCount++;
        } else {
          if (!(data.version === "v1")) {
            if (validate.errors === null) validate.errors = [];
            validate.errors.push({ keywordLocation: "#/properties/version/enum", instanceLocation: "#/version" });
            errorCount++;
          }
        }
      }
      if ("leases" in data && hasOwn(data, "leases")) {
        if (!(typeof data.leases === "object" && data.leases && !Array.isArray(data.leases))) {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/properties/leases/type", instanceLocation: "#/leases" });
          errorCount++;
        } else {
          if (!("access" in data.leases && hasOwn(data.leases, "access"))) {
            if (validate.errors === null) validate.errors = [];
            validate.errors.push({ keywordLocation: "#/properties/leases/required", instanceLocation: "#/leases/access" });
            errorCount++;
          }
          if ("access" in data.leases && hasOwn(data.leases, "access")) {
            if (!(typeof data.leases.access === "string")) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/properties/access/type", instanceLocation: "#/leases/access" });
              errorCount++;
            } else {
              if (!(data.leases.access === "full" || data.leases.access === "granular" || data.leases.access === "scoped")) {
                if (validate.errors === null) validate.errors = [];
                validate.errors.push({ keywordLocation: "#/properties/leases/properties/access/enum", instanceLocation: "#/leases/access" });
                errorCount++;
              }
            }
          }
          if ("scope" in data.leases && hasOwn(data.leases, "scope")) {
            if (!Array.isArray(data.leases.scope)) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/properties/scope/type", instanceLocation: "#/leases/scope" });
              errorCount++;
            } else {
              const prev1 = errorCount;
              if (data.leases.scope.length < 1) {
                if (validate.errors === null) validate.errors = [];
                validate.errors.push({ keywordLocation: "#/properties/leases/properties/scope/minItems", instanceLocation: "#/leases/scope" });
                errorCount++;
              }
              for (let i = 0; i < data.leases.scope.length; i++) {
                if (i in data.leases.scope && hasOwn(data.leases.scope, i)) {
                  if (!(typeof data.leases.scope[i] === "string")) {
                    if (validate.errors === null) validate.errors = [];
                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/scope/items/type", instanceLocation: "#/leases/scope/" + i });
                    errorCount++;
                  } else {
                    if (!(data.leases.scope[i] === "send-manifest" || data.leases.scope[i] === "get-manifest" || data.leases.scope[i] === "logs" || data.leases.scope[i] === "shell" || data.leases.scope[i] === "events" || data.leases.scope[i] === "status" || data.leases.scope[i] === "restart" || data.leases.scope[i] === "hostname-migrate" || data.leases.scope[i] === "ip-migrate")) {
                      if (validate.errors === null) validate.errors = [];
                      validate.errors.push({ keywordLocation: "#/properties/leases/properties/scope/items/enum", instanceLocation: "#/leases/scope/" + i });
                      errorCount++;
                    }
                  }
                }
              }
              if (errorCount === prev1) {
                if (!unique(data.leases.scope)) {
                  if (validate.errors === null) validate.errors = [];
                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/scope/uniqueItems", instanceLocation: "#/leases/scope" });
                  errorCount++;
                }
              }
            }
          }
          if ("permissions" in data.leases && hasOwn(data.leases, "permissions")) {
            if (!Array.isArray(data.leases.permissions)) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/type", instanceLocation: "#/leases/permissions" });
              errorCount++;
            } else {
              if (data.leases.permissions.length < 1) {
                if (validate.errors === null) validate.errors = [];
                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/minItems", instanceLocation: "#/leases/permissions" });
                errorCount++;
              }
              for (let j = 0; j < data.leases.permissions.length; j++) {
                if (j in data.leases.permissions && hasOwn(data.leases.permissions, j)) {
                  if (!(typeof data.leases.permissions[j] === "object" && data.leases.permissions[j] && !Array.isArray(data.leases.permissions[j]))) {
                    if (validate.errors === null) validate.errors = [];
                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/type", instanceLocation: "#/leases/permissions/" + j });
                    errorCount++;
                  } else {
                    if (!("provider" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "provider"))) {
                      if (validate.errors === null) validate.errors = [];
                      validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/required", instanceLocation: "#/leases/permissions/" + j + "/provider" });
                      errorCount++;
                    }
                    if (!("access" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "access"))) {
                      if (validate.errors === null) validate.errors = [];
                      validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/required", instanceLocation: "#/leases/permissions/" + j + "/access" });
                      errorCount++;
                    }
                    if ("provider" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "provider")) {
                      if (!(typeof data.leases.permissions[j].provider === "string")) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/provider/type", instanceLocation: "#/leases/permissions/" + j + "/provider" });
                        errorCount++;
                      } else {
                        const prev2 = errorCount;
                        if (errorCount === prev2) {
                          if (!(pattern0.test(data.leases.permissions[j].provider))) {
                            if (validate.errors === null) validate.errors = [];
                            validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/provider/pattern", instanceLocation: "#/leases/permissions/" + j + "/provider" });
                            errorCount++;
                          }
                        }
                      }
                    }
                    if ("access" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "access")) {
                      if (!(typeof data.leases.permissions[j].access === "string")) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/access/type", instanceLocation: "#/leases/permissions/" + j + "/access" });
                        errorCount++;
                      } else {
                        if (!(data.leases.permissions[j].access === "full" || data.leases.permissions[j].access === "scoped" || data.leases.permissions[j].access === "granular")) {
                          if (validate.errors === null) validate.errors = [];
                          validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/access/enum", instanceLocation: "#/leases/permissions/" + j + "/access" });
                          errorCount++;
                        }
                      }
                    }
                    if ("scope" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "scope")) {
                      if (!(Array.isArray(data.leases.permissions[j].scope))) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/scope/type", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                        errorCount++;
                      } else {
                        const prev3 = errorCount;
                        if (data.leases.permissions[j].scope.length < 1) {
                          if (validate.errors === null) validate.errors = [];
                          validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/scope/minItems", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                          errorCount++;
                        }
                        for (let k = 0; k < data.leases.permissions[j].scope.length; k++) {
                          if (k in data.leases.permissions[j].scope && hasOwn(data.leases.permissions[j].scope, k)) {
                            if (!(typeof data.leases.permissions[j].scope[k] === "string")) {
                              if (validate.errors === null) validate.errors = [];
                              validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/scope/items/type", instanceLocation: "#/leases/permissions/" + j + "scope/" + k });
                              errorCount++;
                            } else {
                              if (!(data.leases.permissions[j].scope[k] === "send-manifest" || data.leases.permissions[j].scope[k] === "get-manifest" || data.leases.permissions[j].scope[k] === "logs" || data.leases.permissions[j].scope[k] === "shell" || data.leases.permissions[j].scope[k] === "events" || data.leases.permissions[j].scope[k] === "status" || data.leases.permissions[j].scope[k] === "restart" || data.leases.permissions[j].scope[k] === "hostname-migrate" || data.leases.permissions[j].scope[k] === "ip-migrate")) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/scope/items/enum", instanceLocation: "#/leases/permissions/" + j + "scope/" + k });
                                errorCount++;
                              }
                            }
                          }
                        }
                        if (errorCount === prev3) {
                          if (!unique(data.leases.permissions[j].scope)) {
                            if (validate.errors === null) validate.errors = [];
                            validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/scope/uniqueItems", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                            errorCount++;
                          }
                        }
                      }
                    }
                    if ("deployments" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "deployments")) {
                      if (!(Array.isArray(data.leases.permissions[j].deployments))) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/type", instanceLocation: "#/leases/permissions/" + j + "/deployments" });
                        errorCount++;
                      } else {
                        if (data.leases.permissions[j].deployments.length < 1) {
                          if (validate.errors === null) validate.errors = [];
                          validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/minItems", instanceLocation: "#/leases/permissions/" + j + "/deployments" });
                          errorCount++;
                        }
                        for (let l = 0; l < data.leases.permissions[j].deployments.length; l++) {
                          if (l in data.leases.permissions[j].deployments && hasOwn(data.leases.permissions[j].deployments, l)) {
                            if (!(typeof data.leases.permissions[j].deployments[l] === "object" && data.leases.permissions[j].deployments[l] && !Array.isArray(data.leases.permissions[j].deployments[l]))) {
                              if (validate.errors === null) validate.errors = [];
                              validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l });
                              errorCount++;
                            } else {
                              if (!("dseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "dseq"))) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/required", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/dseq" });
                                errorCount++;
                              }
                              if (!("scope" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "scope"))) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/required", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/scope" });
                                errorCount++;
                              }
                              if (!("services" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "services"))) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/required", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/services" });
                                errorCount++;
                              }
                              if ("gseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "gseq") && !("dseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "dseq"))) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies/gseq", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l });
                                errorCount++;
                              }
                              if ("oseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "oseq") && !("dseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "dseq") && "gseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "gseq"))) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies/oseq", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l });
                                errorCount++;
                              }
                              if ("services" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "services") && !("dseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "dseq"))) {
                                if (validate.errors === null) validate.errors = [];
                                validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/dependencies/services", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l });
                                errorCount++;
                              }
                              if ("dseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "dseq")) {
                                if (!(Number.isInteger(data.leases.permissions[j].deployments[l].dseq))) {
                                  if (validate.errors === null) validate.errors = [];
                                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/dseq/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/dseq" });
                                  errorCount++;
                                } else {
                                  if (!(1 <= data.leases.permissions[j].deployments[l].dseq)) {
                                    if (validate.errors === null) validate.errors = [];
                                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/dseq/minimum", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/dseq" });
                                    errorCount++;
                                  }
                                }
                              }
                              if ("scope" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "scope")) {
                                if (!(Array.isArray(data.leases.permissions[j].deployments[l].scope))) {
                                  if (validate.errors === null) validate.errors = [];
                                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/scope" });
                                  errorCount++;
                                } else {
                                  const prev4 = errorCount;
                                  if (data.leases.permissions[j].deployments[l].scope.length < 1) {
                                    if (validate.errors === null) validate.errors = [];
                                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/minItems", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/scope" });
                                    errorCount++;
                                  }
                                  for (let m = 0; m < data.leases.permissions[j].deployments[l].scope.length; m++) {
                                    if (m in data.leases.permissions[j].deployments[l].scope && hasOwn(data.leases.permissions[j].deployments[l].scope, m)) {
                                      if (!(typeof data.leases.permissions[j].deployments[l].scope[m] === "string")) {
                                        if (validate.errors === null) validate.errors = [];
                                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/items/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "scope/" + m });
                                        errorCount++;
                                      } else {
                                        if (!(data.leases.permissions[j].deployments[l].scope[m] === "send-manifest" || data.leases.permissions[j].deployments[l].scope[m] === "get-manifest" || data.leases.permissions[j].deployments[l].scope[m] === "logs" || data.leases.permissions[j].deployments[l].scope[m] === "shell" || data.leases.permissions[j].deployments[l].scope[m] === "events" || data.leases.permissions[j].deployments[l].scope[m] === "status" || data.leases.permissions[j].deployments[l].scope[m] === "restart" || data.leases.permissions[j].deployments[l].scope[m] === "hostname-migrate" || data.leases.permissions[j].deployments[l].scope[m] === "ip-migrate")) {
                                          if (validate.errors === null) validate.errors = [];
                                          validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/items/enum", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "scope/" + m });
                                          errorCount++;
                                        }
                                      }
                                    }
                                  }
                                  if (errorCount === prev4) {
                                    if (!unique(data.leases.permissions[j].deployments[l].scope)) {
                                      if (validate.errors === null) validate.errors = [];
                                      validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/scope/uniqueItems", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/scope" });
                                      errorCount++;
                                    }
                                  }
                                }
                              }
                              if ("gseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "gseq")) {
                                if (!(Number.isInteger(data.leases.permissions[j].deployments[l].gseq))) {
                                  if (validate.errors === null) validate.errors = [];
                                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/gseq/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/gseq" });
                                  errorCount++;
                                } else {
                                  if (!(0 <= data.leases.permissions[j].deployments[l].gseq)) {
                                    if (validate.errors === null) validate.errors = [];
                                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/gseq/minimum", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/gseq" });
                                    errorCount++;
                                  }
                                }
                              }
                              if ("oseq" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "oseq")) {
                                if (!(Number.isInteger(data.leases.permissions[j].deployments[l].oseq))) {
                                  if (validate.errors === null) validate.errors = [];
                                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/oseq/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/oseq" });
                                  errorCount++;
                                } else {
                                  if (!(0 <= data.leases.permissions[j].deployments[l].oseq)) {
                                    if (validate.errors === null) validate.errors = [];
                                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/oseq/minimum", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/oseq" });
                                    errorCount++;
                                  }
                                }
                              }
                              if ("services" in data.leases.permissions[j].deployments[l] && hasOwn(data.leases.permissions[j].deployments[l], "services")) {
                                if (!(Array.isArray(data.leases.permissions[j].deployments[l].services))) {
                                  if (validate.errors === null) validate.errors = [];
                                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/services" });
                                  errorCount++;
                                } else {
                                  const prev5 = errorCount;
                                  if (data.leases.permissions[j].deployments[l].services.length < 1) {
                                    if (validate.errors === null) validate.errors = [];
                                    validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/minItems", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/services" });
                                    errorCount++;
                                  }
                                  for (let n = 0; n < data.leases.permissions[j].deployments[l].services.length; n++) {
                                    if (n in data.leases.permissions[j].deployments[l].services && hasOwn(data.leases.permissions[j].deployments[l].services, n)) {
                                      if (!(typeof data.leases.permissions[j].deployments[l].services[n] === "string")) {
                                        if (validate.errors === null) validate.errors = [];
                                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/items/type", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "services/" + n });
                                        errorCount++;
                                      } else {
                                        if (data.leases.permissions[j].deployments[l].services[n].length < 1 || stringLength(data.leases.permissions[j].deployments[l].services[n]) < 1) {
                                          if (validate.errors === null) validate.errors = [];
                                          validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/items/minLength", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "services/" + n });
                                          errorCount++;
                                        }
                                      }
                                    }
                                  }
                                  if (errorCount === prev5) {
                                    if (!unique(data.leases.permissions[j].deployments[l].services)) {
                                      if (validate.errors === null) validate.errors = [];
                                      validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/properties/services/uniqueItems", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/services" });
                                      errorCount++;
                                    }
                                  }
                                }
                              }
                              for (const key0 of Object.keys(data.leases.permissions[j].deployments[l])) {
                                if (key0 !== "dseq" && key0 !== "scope" && key0 !== "gseq" && key0 !== "oseq" && key0 !== "services") {
                                  if (validate.errors === null) validate.errors = [];
                                  validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/properties/deployments/items/additionalProperties", instanceLocation: "#/leases/permissions/" + j + "deployments/" + l + "/" + pointerPart(key0) });
                                  errorCount++;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    for (const key1 of Object.keys(data.leases.permissions[j])) {
                      if (key1 !== "provider" && key1 !== "access" && key1 !== "scope" && key1 !== "deployments") {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/additionalProperties", instanceLocation: "#/leases/permissions/" + j + "/" + pointerPart(key1) });
                        errorCount++;
                      }
                    }
                    const sub0 = (() => {
                      let errorCount = 0;
                      if ("access" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "access")) {
                        if (!(data.leases.permissions[j].access === "scoped")) errorCount++;
                      }
                      return errorCount === 0;
                    })();
                    if (sub0) {
                      if (!("scope" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "scope"))) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/0/then/required", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                        errorCount++;
                      }
                      if ("scope" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "scope")) {
                        if (Array.isArray(data.leases.permissions[j].scope)) {
                          if (data.leases.permissions[j].scope.length < 1) {
                            if (validate.errors === null) validate.errors = [];
                            validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/0/then/properties/scope/minItems", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                            errorCount++;
                          }
                        }
                      }
                      if ("deployments" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "deployments")) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/0/then/properties/deployments", instanceLocation: "#/leases/permissions/" + j + "/deployments" });
                        errorCount++;
                      }
                    }
                    const sub1 = (() => {
                      let errorCount = 0;
                      if ("access" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "access")) {
                        if (!(data.leases.permissions[j].access === "granular")) errorCount++;
                      }
                      return errorCount === 0;
                    })();
                    if (sub1) {
                      if (!("deployments" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "deployments"))) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/1/then/required", instanceLocation: "#/leases/permissions/" + j + "/deployments" });
                        errorCount++;
                      }
                      if ("scope" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "scope")) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/1/then/properties/scope", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                        errorCount++;
                      }
                    }
                    const sub2 = (() => {
                      let errorCount = 0;
                      if ("access" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "access")) {
                        if (!(data.leases.permissions[j].access === "full")) errorCount++;
                      }
                      return errorCount === 0;
                    })();
                    if (sub2) {
                      if ("scope" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "scope")) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/2/then/properties/scope", instanceLocation: "#/leases/permissions/" + j + "/scope" });
                        errorCount++;
                      }
                      if ("deployments" in data.leases.permissions[j] && hasOwn(data.leases.permissions[j], "deployments")) {
                        if (validate.errors === null) validate.errors = [];
                        validate.errors.push({ keywordLocation: "#/properties/leases/properties/permissions/items/allOf/2/then/properties/deployments", instanceLocation: "#/leases/permissions/" + j + "/deployments" });
                        errorCount++;
                      }
                    }
                  }
                }
              }
            }
          }
          for (const key2 of Object.keys(data.leases)) {
            if (key2 !== "access" && key2 !== "scope" && key2 !== "permissions") {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/additionalProperties", instanceLocation: "#/leases/" + pointerPart(key2) });
              errorCount++;
            }
          }
          const sub3 = (() => {
            let errorCount = 0;
            if ("access" in data.leases && hasOwn(data.leases, "access")) {
              if (!(data.leases.access === "full")) errorCount++;
            }
            return errorCount === 0;
          })();
          if (sub3) {
            if ("permissions" in data.leases && hasOwn(data.leases, "permissions")) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/allOf/0/then/properties/permissions", instanceLocation: "#/leases/permissions" });
              errorCount++;
            }
            if ("scope" in data.leases && hasOwn(data.leases, "scope")) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/allOf/0/then/properties/scope", instanceLocation: "#/leases/scope" });
              errorCount++;
            }
          }
          const sub4 = (() => {
            let errorCount = 0;
            if ("access" in data.leases && hasOwn(data.leases, "access")) {
              if (!(data.leases.access === "scoped")) errorCount++;
            }
            return errorCount === 0;
          })();
          if (sub4) {
            if (!("scope" in data.leases && hasOwn(data.leases, "scope"))) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/allOf/1/then/required", instanceLocation: "#/leases/scope" });
              errorCount++;
            }
            if ("scope" in data.leases && hasOwn(data.leases, "scope")) {
              if (Array.isArray(data.leases.scope)) {
                if (data.leases.scope.length < 1) {
                  if (validate.errors === null) validate.errors = [];
                  validate.errors.push({ keywordLocation: "#/properties/leases/allOf/1/then/properties/scope/minItems", instanceLocation: "#/leases/scope" });
                  errorCount++;
                }
              }
            }
            if ("permissions" in data.leases && hasOwn(data.leases, "permissions")) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/allOf/1/then/properties/permissions", instanceLocation: "#/leases/permissions" });
              errorCount++;
            }
          }
          const sub5 = (() => {
            let errorCount = 0;
            if (!("access" in data.leases && hasOwn(data.leases, "access"))) errorCount++;
            if ("access" in data.leases && hasOwn(data.leases, "access")) {
              if (!(data.leases.access === "granular")) errorCount++;
            }
            return errorCount === 0;
          })();
          if (sub5) {
            if (!("permissions" in data.leases && hasOwn(data.leases, "permissions"))) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/allOf/2/then/required", instanceLocation: "#/leases/permissions" });
              errorCount++;
            }
            if ("scope" in data.leases && hasOwn(data.leases, "scope")) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/properties/leases/allOf/2/then/properties/scope", instanceLocation: "#/leases/scope" });
              errorCount++;
            }
          }
        }
      }
      for (const key3 of Object.keys(data)) {
        if (key3 !== "iss" && key3 !== "iat" && key3 !== "nbf" && key3 !== "exp" && key3 !== "jti" && key3 !== "version" && key3 !== "leases") {
          if (validate.errors === null) validate.errors = [];
          validate.errors.push({ keywordLocation: "#/additionalProperties", instanceLocation: "#/" + pointerPart(key3) });
          errorCount++;
        }
      }
      const sub6 = (() => {
        let errorCount = 0;
        if (!("leases" in data && hasOwn(data, "leases"))) errorCount++;
        if ("leases" in data && hasOwn(data, "leases")) {
          if (typeof data.leases === "object" && data.leases && !Array.isArray(data.leases)) {
            if (!("access" in data.leases && hasOwn(data.leases, "access"))) errorCount++;
            if ("access" in data.leases && hasOwn(data.leases, "access")) {
              if (!(data.leases.access === "granular")) errorCount++;
            }
          }
        }
        return errorCount === 0;
      })();
      if (sub6) {
        if ("leases" in data && hasOwn(data, "leases")) {
          if (typeof data.leases === "object" && data.leases && !Array.isArray(data.leases)) {
            if (!("permissions" in data.leases && hasOwn(data.leases, "permissions"))) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/allOf/0/then/properties/leases/required", instanceLocation: "#/leases/permissions" });
              errorCount++;
            }
            if ("scope" in data.leases && hasOwn(data.leases, "scope")) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/allOf/0/then/properties/leases/properties/scope", instanceLocation: "#/leases/scope" });
              errorCount++;
            }
          }
        }
      }
      const sub7 = (() => {
        let errorCount = 0;
        if (!("leases" in data && hasOwn(data, "leases"))) errorCount++;
        if ("leases" in data && hasOwn(data, "leases")) {
          if (typeof data.leases === "object" && data.leases && !Array.isArray(data.leases)) {
            if (!("permissions" in data.leases && hasOwn(data.leases, "permissions"))) errorCount++;
            if ("permissions" in data.leases && hasOwn(data.leases, "permissions")) {
              if (!Array.isArray(data.leases.permissions)) {
                errorCount++;
              } else {
                if (data.leases.permissions.length < 1) errorCount++;
              }
            }
          }
        }
        return errorCount === 0;
      })();
      if (sub7) {
        if ("leases" in data && hasOwn(data, "leases")) {
          if (typeof data.leases === "object" && data.leases && !Array.isArray(data.leases)) {
            if (!("access" in data.leases && hasOwn(data.leases, "access"))) {
              if (validate.errors === null) validate.errors = [];
              validate.errors.push({ keywordLocation: "#/allOf/1/then/properties/leases/required", instanceLocation: "#/leases/access" });
              errorCount++;
            }
            if ("access" in data.leases && hasOwn(data.leases, "access")) {
              if (!(data.leases.access === "granular")) {
                if (validate.errors === null) validate.errors = [];
                validate.errors.push({ keywordLocation: "#/allOf/1/then/properties/leases/properties/access/const", instanceLocation: "#/leases/access" });
                errorCount++;
              }
            }
          }
        }
      }
    }
    return errorCount === 0;
  };
  return ref0;
})(); ;
